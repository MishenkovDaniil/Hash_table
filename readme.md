# Сравнение работы хэш-функций и оптимизация работы поиска хэш-таблицы ++

***В рамках проекта были исследованы распределения различных хэш-функций и оптимизирован поиск по хэш-таблице с помощью различных приемов***

# Исследование хэш-функций

## Введение 

`Хэш-таблица` - структура данных, позволяющая хранить пары ключ-значение и выполнять три основные операции: вставку, поиск и удаление (в рамках исследования операция удаления не была реализована, так как в ней не было необходимости). Мы реализовали и использовали так называемую хэш-таблицу с цепочками, представляющую собой массив списков, в который помещали данные произвольного значения и длины, а именно строки "Войны и Мира" Льва Толстого. `Хэш-функция` в свою очередь по переданному ей значению выдает ключ, соответствующий номеру списка, в котором он находится или в который его следует поместить. В общем смысле, `хэш-функция` - функция, сопоставляющая некоторому множеству байт уникальное значение.

////////////////////////////////////////////////////////////////////

Степень хорошести хэш-функции и почему важна уникальность ++
////////////////////////////////////////////////////////////////////

## Методы исследования 

В рамках исследования распределения на вход каждой функции было подано 8503 уникальных слова, а результат их выполнения был взят по модулю количества списков внутри хэш-таблицы, равному 499. В ходе работы со строками были рассмотрены следующие хэш-функции:
- `size_t hash_ret_1 (char *string)` - `хэш-функция`, всегда возвращающая единицу,
- `size_t hash_first_ch (char *string)` - `хэш-функция`, возвращающая ASCII-код первого символа, 
- `size_t hash_strlen (char *string)` - `хэш-функция`, возвращающая длину поданной строки,
- `size_t hash_ch_sum (char *string)` - `хэш-функция`, возвращающая сумму  ASCII-кодов строки,
- `size_t hash_rotr (char *string)` - `хэш-функция`, которая начиная с нулевого значения возвращаемого значения выполняет для каждого символа строки циклический сдвиг этой переменной вправо и ее побитовое отрицание с этим символом,
- `size_t hash_rotl (char *string)` - аналогичная предыдущей `хэш-функция`, выполняющая побитовый циклический сдвиг влево,
- `size_t hash_crc64 (char *string)` - `хэш-функция` crc32 с 64-битной маской.

## Результаты 

*Замечание: на графиках представлено точное распределение хэш-функций в рамках исследования.*

Применение первой `хэш-функции` (см. график 1) очевидно бесполезно, так как оно приводит к проведению операции поиска (и удаления) за линейное время, что можно наглядно увидеть на графике.

![](/data/histograms/histogram_of_1_func.png?raw=true)

////////////////////////////////////////////////////////////////////

заменить на график 1: распределение значений первой `хэш-функции`, и аналогично далее
////////////////////////////////////////////////////////////////////

`Хэш-функции`, возвращающие код первого символа и длину(см. график 2), выдают на выходе больше значений, но все также приводят к большому количеству коллизий (несколько тысяч при количестве слов в 8 с половиной тысяч) и, соответственно, к долгому поиску в ряде случаев.

![](/data/histograms/histogram_of_2_3_funcs.png?raw=true)

Более хорошее распределение показали последние 4 `хэш-функции`(см. график 3). Их распределение в разы лучше чем у ранее рассмотренных хэш-функций: в худшем случае длина списка не превышает 5% от количества всех слов, а в подавляющем большинстве списков лежит до 10-20 слов. Можно также заметить, что количество 'длинных' списков наименьшее при использовании последней, `crc-64`, `хэш-функции` (поэтому поиск элементов в следующей части работы был произведен именно с ней).

![](/data/histograms/histogram_of_4_5_6_7_funcs.png?raw=true)


## Обсуждение и выводы 



# Оптимизация поиска по хэш-таблице

