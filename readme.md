# Сравнение работы хэш-функций и оптимизация работы поиска хэш-таблицы ++

***В рамках проекта были исследованы распределения различных хэш-функций и оптимизирован поиск по хэш-таблице с помощью различных приемов***

# Исследование хэш-функций

## Введение 

`Хэш-таблица` - структура данных, позволяющая хранить пары ключ-значение и выполнять три основные операции: вставку, поиск и удаление (в рамках исследования операция удаления не была реализована, так как в ней не было необходимости). Мы реализовали и использовали так называемую хэш-таблицу с цепочками, представляющую собой массив списков, в который помещали данные произвольного значения и длины, а именно строки "Войны и Мира" Льва Толстого. `Хэш-функция` в свою очередь по переданному ей значению выдает ключ, соответствующий номеру списка, в котором он находится или в который его следует поместить. В общем смысле, `хэш-функция` - функция, сопоставляющая некоторому множеству байт уникальное значение.

////////////////////////////////////////////////////////////////////

Степень хорошести хэш-функции и почему важна уникальность ++
////////////////////////////////////////////////////////////////////

## Методы исследования 

В рамках исследования распределения на вход каждой функции было подано 8503 уникальных слова, а результат их выполнения был взят по модулю количества списков внутри хэш-таблицы, равному 499. В ходе работы со строками были рассмотрены следующие хэш-функции:
1. `size_t hash_ret_1 (char *string)` - `хэш-функция`, всегда возвращающая единицу,
2. `size_t hash_first_ch (char *string)` - `хэш-функция`, возвращающая ASCII-код первого символа, 
3. `size_t hash_strlen (char *string)` - `хэш-функция`, возвращающая длину поданной строки,
4. `size_t hash_ch_sum (char *string)` - `хэш-функция`, возвращающая сумму  ASCII-кодов строки,
5. `size_t hash_rotr (char *string)` - `хэш-функция`, которая начиная с нулевого значения возвращаемого значения выполняет для каждого символа строки циклический сдвиг этой переменной вправо и ее побитовое отрицание с этим символом,
6. `size_t hash_rotl (char *string)` - аналогичная предыдущей `хэш-функция`, но выполняющая побитовый циклический сдвиг влево,
7. `size_t hash_crc64 (char *string)` - `хэш-функция` crc32 с 64-битной маской.

## Результаты 

*Замечание: на графиках представлено точное распределение хэш-функций в рамках исследования.*

Применение первой `хэш-функции` (см. график 1) очевидно бесполезно, так как оно приводит к проведению операции поиска (и удаления) за линейное время, что можно наглядно увидеть на графике.

![](/data/histograms/histogram_of_1_func.png?raw=true)

`Хэш-функции`, возвращающие код первого символа и длину(см. график 2), выдают на выходе больше значений, но все также приводят к большому количеству коллизий (несколько тысяч при количестве слов в 8 с половиной тысяч) и, соответственно, к долгому поиску в ряде случаев.

![](/data/histograms/histogram_of_2_3_funcs.png?raw=true)

4-ая и 5-ая `хэщ-функции` (см. график 3) распределяют строки заметно лучше, чем ранее рассмотренные: хоть отклонения от среднего значения в ~50 значений на лист являются частыми, но все они небольшие относительно ранее увиденных, а именно, максимальное отклонение - примерно в 2 раза.

![](/data/histograms/histogram_of_4_5_funcs.png?raw=true)

Последние 2 `хэш-функции`(см. график 4) показали наиболее хорошие распределения, которые в разы лучше чем у ранее рассмотренных: в худшем случае длина списка при их использовании не превышает 5% от количества всех слов, а в подавляющем большинстве списков лежит до 10-20 слов. Можно также заметить, что количество 'длинных' списков наименьшее в случае последней, `crc-64`, `хэш-функции` (поэтому поиск элементов в следующей части работы был произведен именно с ней).

![](/data/histograms/histogram_of_6_7_funcs.png?raw=true)


## Обсуждение и выводы 

...


# Оптимизация поиска по хэш-таблице

Поскольку хэш-таблицы используются для быстрого поиска среди большого количеству данных, то даже при использовании наилучшей хэш-функции необходимо оптимизировать работу хэш-таблицы и в других времязатратных местах. 

Для того чтобы найти те функции и команды, на выполнение которых затрачивается наибольшее время при поиске данных, воспользуемся профайлером `callgrind`, позволяющим увидеть время работы каждой вызванной функции в процентах от общего времени работы. На рис.1 представлен результат работы профайлера для текущей версии программы.

- Отметим, что хэш-таблица не подразумевает частого добавления данных и используется в основном именно для поиска, поэтому мы произвели 5 миллионов итераций поиска случайных элементов, чтобы не учитывать время работы функций по заполнению таблицы. 
- Также теперь мы рассматриваем только одну хэш-таблицу с  `crc-64` `хэш-функцией`.
- Так как проект является учебным, то мы выполним три оптимизации, используя различные методы: использование интринсик-функций, ассемблерная вставка,  

рис.1 start valgrind output 


## Методы исследования и результаты

Очевидно, что необходимо оптимизировать работу хэш-функции, так как на ее выполнение занимает практически 80% всего времени. Заметим, что среди интринсик-функций существует функция `unsigned __int64 _mm_crc32_u64 (unsigned __int64 crc, unsigned __int64 v)`, преобразующая 8-байтное значение v по алгоритму crc32 (начиная со значения crc). Поэтому мы можем значительно ускорить работу нашей хэш-функции, переписав ее на основе `_mm_crc32_u64`, обрабатывая по алгоритму crc32 блоки по 8 байт одновременно.

Результат этой оптимизации в рамках профайлера представлен на рис.2.

рис.2: valgrind output after intinsic hash optimization

Проанализировав работу самой времязатратной на данный момент функции `hash_find ()` можно понять, что почти все время занимает линейный поиск по элементам списка. Ассемблерный код цикла после компиляции программы представлен на рис.3. Видно, что при использовании флага -O0, этот цикл занимает большое количество кода и создает множество меток, перемещения между которыми заметно замедляют работу поиска в цикле. Для оптимизации небольшой части функции мы выбрали оптимизацию с помощью ассемблерной вставки: мы переписали код цикла, учитывая логику его работы и невооруженным глазом видно, что количество пересылок и прыжков по меткам заметно сократилось (рис.4). Увидеть формальный результат можно применив профайлер к новой программе (рис.5).

рис.3 вырезка с godbolt

рис.4 код ассемблерной вставка

рис.5 valgrind output after asm input

Последнюю оптимизацию проведем с функцией сравнения строк `strmcp ()`, написав ее самостоятельной в отдельном ассемблерном файле и вызывая собственную функцию вместо стандартной. По результатам профайлинга (рис.6) наша функция действительно работает быстрее стандартной. 

рис.6 profiler output at end

## Обсуждение 

Абсолютное время работы и его изменения 

сравнение с O1 O2 O3

## Результаты 

...





